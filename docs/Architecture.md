# mxspp Architecture Design Document

## 1. Overview

`mxspp` is a modern, dynamically typed programming language. It aims to deliver excellent execution performance through Just-In-Time (JIT) compilation while maintaining high flexibility and expressiveness in the language itself.

The core design goal of this project is to build a complete, modular, and extensible compiler and runtime environment. Its technology stack mainly includes C++23, the LLVM framework, and the PEGTL parsing library.

## 2. Design Philosophy

* **Modularity:** The project is decomposed into a set of highly cohesive, loosely coupled independent components (libraries). Each component has a single responsibility, making it easy to develop, test, and maintain independently.
* **Performance-Oriented:** By using LLVM’s JIT compilation, user scripts are directly compiled into target-optimized native machine code. Additionally, by shipping the runtime library in LLVM IR (bitcode) form and linking it with user code, we achieve cross-module Link-Time Optimization (LTO)—especially function inlining—to maximize performance.
* **Modern C++ Practices:** The entire compiler frontend and core libraries are written in modern C++ (C++23), leveraging its strong type system and object-oriented features to ensure robustness and maintainability.
* **Clear Abstraction Boundaries:** There is a strict separation between the compile-time environment (the C++ compiler itself) and the runtime environment (the JIT-generated code). These two worlds are connected via a clear C-ABI interface layer (`runtime`).

## 3. Core Execution Flow

When the user runs `mxspp hello.mxs`, the full lifecycle from source file to final execution result is as follows:

1.  **Driver Program (`mxs-driver`):**
* `mxspp.exe` acts as the main entry point and parses command-line arguments.
* When it detects a script file to run, it loads and calls the `frontend` module.

2.  **Frontend (`libmxsfrontend.so`):**
* **Parsing:** Uses the **PEGTL** library to parse the source code directly. This is a *scanner-less* approach that combines lexical and syntactic analysis in one pass.
* **AST Construction:** During parsing, PEGTL’s `action` templates are used to directly construct a series of C++ objects in memory representing the code’s structure. These objects form the **Abstract Syntax Tree (AST)**. AST node definitions come from `libmxscore.so`.
* The frontend's final output is a pointer to the AST root node.

3.  **Backend (`libmxsbackend.so`):**
* **Code Generation:** The backend receives the AST generated by the frontend.
* It uses the **Visitor Pattern** to traverse every AST node.
* For each node, it generates equivalent **LLVM IR**. For example:
* Encountering an integer literal `3`, it generates a `call` instruction to invoke the runtime function `@runtime_create_orgint(i64 3)` to create a boxed integer object.
* For an infix expression `a + b`, it generates `call @runtime_add(%a, %b)`.
* The backend’s final output is an `llvm::Module` object containing the full user program logic.

4.  **JIT Engine (`libmxsjit.so`):**
* **Loading and Linking:** The JIT engine receives the `llvm::Module` produced by the backend. At the same time, it loads the precompiled runtime bitcode file **`runtime.bc`** from disk. It then **links** these two modules in memory into a single complete module containing all code (user code + runtime functions).
* **Optimization:** This is critical for performance. The JIT engine runs a series of LLVM optimization passes on the merged module. Because the optimizer can see both the user code and the internals of the runtime functions at this point, it can perform powerful cross-function optimizations such as **function inlining**.
* **Compilation and Execution:** The optimized LLVM IR is JIT-compiled into native machine code.
* The JIT engine obtains a pointer to the main function (or top-level script code) and calls it to start execution.

## 4. Component Architecture

The project is clearly divided into the following logical libraries (built as `.so` files) and a runtime file:

* `mxspp` (`mxs-driver`)
* **Role:** Top-level orchestrator / executable entry point.
* **Responsibilities:** Parses command-line input and coordinates the workflow of all other modules.

* `libmxscore.so`
* **Role:** **Core data structures and type definitions.** The foundation of the project's dependency graph.
* **Responsibilities:** Defines all core concepts of the language, including:
* Base and derived classes for AST nodes (`MXASTNode`, `LetStatementNode` ...).
* C++ class implementations of built-in language types (`class MXObject`, `class MXInt` ...).
* C-style memory layout for runtime objects (`struct MXObject_t` ...), shared by `backend` and `runtime`.

* `libmxsfrontend.so`
* **Role:** **Frontend / Parser.**
* **Responsibilities:** Implements a PEGTL-based parser that converts source code into an AST.
* **Depends on:** `libmxscore.so` (for creating AST nodes).

* `libmxsbackend.so`
* **Role:** **Backend / Code Generator.**
* **Responsibilities:** Implements `CodeGenVisitor` to translate the AST into LLVM IR.
* **Depends on:** `libmxsfrontend.so` (to understand AST structure), `libmxscore.so`, `LLVM`.

* `runtime.bc`
* **Role:** **Runtime library / C-ABI interface.** This is the bridge between the C++ world and the JIT world.
* **Responsibilities:** Provides a set of `extern "C"` functions (like `runtime_add`, `runtime_create_orgint`) that JIT-generated IR can call. These functions internally call high-level C++ methods defined in `libmxscore.so`.
* **Format:** An LLVM bitcode file loaded and linked during the JIT phase.

* `libmxsjit.so`
* **Role:** **JIT Engine.**
* **Responsibilities:** Wraps LLVM’s OrcJIT, handling module linking, optimization, and execution.
* **Depends on:** `libmxscore.so` (may need type definitions), `LLVM`.

* `libmxsshell.so`
* **Role:** **Interactive Interpreter (REPL).**
* **Responsibilities:** A higher-level coordinator that repeatedly calls `frontend`, `backend`, and `jit` to enable line-by-line execution.
* **Depends on:** `libmxsfrontend.so`, `libmxsbackend.so`, `libmxsjit.so`.

## 5. Runtime Model

* **Object System:**
* `mxspp` is an object-oriented language in which all values at runtime are objects.
* Implemented via **boxing**. Any value (e.g., integer `3`) is wrapped in a common object structure at runtime.
* All objects inherit from a base class `MXObject`. In memory, they are represented as `struct MXObject_t`, whose header includes a pointer to type information for dynamic type identification and method dispatch.

* **Memory Management:**
* All objects are allocated on the heap.
* To automatically manage memory and avoid leaks, the project needs to implement or integrate a **Garbage Collector (GC)**. This could be a conservative GC like Boehm, or a more precise GC implemented in the future.

## 6. Build System

* The project uses **CMake** for builds, following modern CMake’s modular, target-based practices.
* Each component is defined as an independent `library` or `executable` target.
* Dependencies are explicitly declared using `target_link_libraries`.
* External dependencies (like LLVM) are located and configured via `find_package`.
* Includes a special **custom command (`add_custom_command`)** to compile `runtime.cpp` into `runtime.bc` to support link-time optimization in the JIT phase.
